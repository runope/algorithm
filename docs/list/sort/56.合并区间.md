# [56] 合并区间

> 给出一个区间的集合，请合并所有重叠的区间。
>
> 示例 1:
>
> 输入: intervals = [[1,3],[2,6],[8,10],[15,18]]
>
> 输出: [[1,6],[8,10],[15,18]]
>
> 解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
>
> 示例 2:
>
> 输入: intervals = [[1,4],[4,5]]
>
> 输出: [[1,5]]
>
> 解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。
>
> 提示：
>
> intervals[i][0] <= intervals[i][1]

解区间的题型最重要的就是处理区间之间顺序关系，这能让我们思考逻辑时直接砍掉一半的逻辑节点，对于思考复杂树的难度是指数级下降的。

比如对于本题来说，我们只需要让区间的某一边有序（其实起始位置或结束位置有序都行，下面的解法对起始位置排序）。

这样一来我们对两个区间取并集时，起始位置就一定会取第一个区间的。之后只需要比较第二个区间的起始位置与第一个区间的结束位置，就能知道两个区间是否相交了。这样是新建一个区间还是扩展一个区间的选择就非常好做了。

所以解区间问题的关键点在于优先排序。

```js
var merge = function(intervals) {
  if (intervals.length <= 0) return [];

  // 先按起始位置排序，这样左侧位置就可以不做判断了
  intervals.sort((a, b) => a[0] - b[0]);

  const res = [intervals[0]];

  for (let i = 1; i < intervals.length; i++) {
    const cur = intervals[i];
    const temp = res[res.length - 1];

    if (cur[0] > temp[1]) {
      // 说明区间之间没有交集，此时结果中需要新建一个区间
      res.push(cur);
    } else {
      // 区间之间有交集，取并集
      temp[1] = Math.max(temp[1], cur[1]);
    }
  }
  return res;
};
```
