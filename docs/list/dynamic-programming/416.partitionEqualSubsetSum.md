# [416] 分割等和子集

> 给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。
>
> 注意:
>
> 每个数组中的元素不会超过 100
>
> 数组的大小不会超过 200
>
> 示例 1:
>
> 输入: [1, 5, 11, 5]
>
> 输出: true
>
> 解释: 数组可以分割成 [1, 5, 5] 和 [11].
>
> 示例 2:
>
> 输入: [1, 2, 3, 5]
>
> 输出: false
>
> 解释: 数组不能分割成两个元素和相等的子集.

这道题看上去比较棘手，容易掉入求和比较误区。

但实际上，我们将题目转换一下说法：从该长度为N的数组中取出若干元素，使得其和为sum / 2（sum为原数组的和）。是不是就能很快地看出考察的重点了呢？

没错，就是动态规划分类中一个典型案例——0-1背包问题：有一些确定的选项可选，对于每一个元素，只有取或者不取两个选项，并且最终获得的和等于或不超过某个定值。

知道了考点是动态规划，那么就能直接考虑状态转移方程了。状态转移方程首先要明确*状态*和*选择*两点。在本题中，显然*选择*是数组中的数字，而*状态*就是已选择的数字和是否等于sum / 2了。

由此我们定义出dp数组：dp[i][j] 表示，对于前i个物品，是否能将容量为j的背包恰好装满。

列出状态转移方程：

1. 若当前物品容量超过了背包总容量，则不能取当前物品，与能选前i-1个物品的结果一致
2. 若能取当前物品，则有两种情况，一种是不取当前物品，则与能选前i-1个物品的结果一致，若取当前物品，则判断当前物品i是否正好能装满取之前的背包剩余容量 j - nums[i - 1]

接下来考虑边界条件，

1. 题目已知数组中只包含正整数，因此，sum / 2不为整数的可以直接pass掉。
2. 当背包容量为0时，任何情况都能满足要求(即不装任何东西)。
3. 当数组长度为0时，任何情况都不能满足要求。

就此可以输出代码。

```js
var canPartition = function(nums) {
  const sum = nums.reduce((prev, x) => prev + x);
  if (sum % 2 !== 0) return false;

  const target = sum / 2;
  const n = nums.length;
  // dp[i][j] 表示，对于前i个物品，是否能将容量为j的背包恰好装满
  const dp = Array(n + 1)
    .fill(0)
    .map(x => Array(target + 1).fill(0));

  // 当背包容量为0时，任何情况都能满足要求(不装)
  for (let i = 0; i <= n; i++) {
    dp[i][0] = 1;
  }

  for (let i = 1; i <= n; i++) {
    for (let j = 1; j <= target; j++) {
      if (j - nums[i - 1] < 0) {
        // 当前物品容量超过了背包总容量，则不能取当前物品，与选前i-1个物品的结果一致
        dp[i][j] = dp[i - 1][j];
      } else {
        // 若取当前物品，判断当前物品i是否正好能装满背包剩余容量 j - nums[i - 1]
        dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i - 1]];
      }
    }
  }
  return dp[n][target] === 1;
};
```

我们还能为优化空间复杂度做出一些努力。可以看出，dp[i][j]的状态转移方程都是通过dp[i-1]中的对应的值算出来的，因此每一次遍历都只用到了上一行的计算结果，因此我们就能将二维的dp数组降为一维，从而优化空间复杂度。

这里需要注意的是，因为遍历时用到的依赖为上一行的左侧的值，因此在改为一维数组后，对j的遍历方向一定要从右向左，这样才能保证上一行左侧的值不被当前行遍历所覆盖。

```js
var canPartition = function(nums) {
  const sum = nums.reduce((prev, x) => prev + x);
  if (sum % 2 !== 0) return false;

  const target = sum / 2;
  const n = nums.length;

  const dp = Array(target + 1).fill(0);
  dp[0] = 1;

  for (let i = 1; i <= n; i++) {
    for (let j = target + 1; j > 0; j--) {
      if (j - nums[i - 1] >= 0) {
        // 若取当前物品，判断当前物品i是否正好能装满背包剩余容量 j - nums[i - 1]
        dp[j] = dp[j] || dp[j - nums[i - 1]];
      }
    }
  }
  return dp[target] === 1;
};
```
