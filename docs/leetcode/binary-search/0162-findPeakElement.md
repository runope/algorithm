# [0162] 寻找峰值

> 峰值元素是指其值大于左右相邻值的元素。
>
> 给你一个输入数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。
>
> 你可以假设 nums[-1] = nums[n] = -∞ 。
>
> 示例 1：
>
> 输入：nums = [1,2,3,1]
>
> 输出：2
>
> 解释：3 是峰值元素，你的函数应该返回其索引 2。
>
> 示例 2：
>
> 输入：nums = [1,2,1,3,5,6,4]
>
> 输出：1 或 5 
>
> 解释：你的函数可以返回索引 1，其峰值元素为 2；或者返回索引 5， 其峰值元素为 6。

这个题出的比较好，虽说也是二分但是用到了一些特殊性质
1.按照题目条件，溢出两侧都按无穷小处理，那么必存在峰值
我们先可以考虑两种特殊的情况，第一种是单调递增，那么最后一个值肯定是一个峰值，第二种，单调递减，那么第一个值肯定是峰值
只有不单调（跟准确的说是两端点处单调性相反），才有可能双断点都不是峰值，端点在中间
2.当从中间截断后，哪一边必有峰值？
其实这就是个分治思维，因为截断处两个值比较，大的端点其实就相当于继承了题目中前提，端点相对于溢出的两侧较大，那么大端点那一侧一定有峰值

所以我们可以直接用二分法处理，假设我们nums[pivot_index] > nums[pivot_index + 1]，那么就在左侧，否则在右侧

这个题边界条件还得注意一下

```js
/** 
 * @param {number[]} nums
 * @return {number}
 */
var findPeakElement = function(nums) {
    let left = 0, right = nums.length - 1, pivot_index = 0

    while(left<right) {
        pivot_index = parseInt((left + right)/2)

        if(nums[pivot_index] > nums[pivot_index+1]) right = pivot_index
        else left = pivot_index + 1
    }
    return left
};
```